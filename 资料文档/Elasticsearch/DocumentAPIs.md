#Document APIs
* Single document APIs 单文档API
* * Index API
* * GET API
* * Delete API
* * Update API
* Multi-document APIs 多文档API
* * Multi Get API
* * Bulk API
* * Delete By Query API
* * Update By Query API
* * Reindex API
* 所有CRUD APIs为single-index APIs。`index`参数接受单个索引名，或者指向单个索引的`alias`
## Read and Writing documents
* 介绍
 每个Elasticsearch的索引将会分为分片shards，每个分片可以有多个复制。复制分片被称为复制组，在文档添加或移除时必须保持同步。如果失败了，从一个复制分片读出的结果回合另一个读出的不同。保持复制分片同步和读取服务的过程被称为数据复制模型data replication model。
 Elasticsearch数据复制模型基于主备模型primary-backup model。该模型基于复制组中作为主要分片的单独复制。另外的复制称为复制分片。主分片作为所有索引操作的主要进入点服务。需要验证他们，并保证他们的正确性。一旦一个索引操作被主要分片接受，主分片负债将操作复制到其他复制分片。
 这节的目的是提供一个Elasticsearch分片模型的大体概览，并讨论各种读写操作间的影响
* Basic write model 基础写模型
 Elasticsearch中每个索引操作首先使用`routing`解析到一个复制组，典型的，基于文档ID。一旦确定复制组，操作会在内部重定向到组中当前的主分片。主分片负责验证操作并将操作转发给其他复制。由于副本可以离线，主分片不会请求全部的复制分片复制，相反的，Elasticsearch会维护一个应该接受这个操作的复制分片的列表。这个列表称为in-sync copies并且被主节点维护。这个名称意味着他们是良好的能够保证所有的索引和删除操作处理通知到用户的通知到的复制分片集合。主要分片负责维护不变量并且复制所有操作到集合中的每个复制。
 主要分片遵守以下基本流程：
  1. 验证输入的操作并且拒绝非法的结构（例如：当需要一个数值时，具有一个对象字段）
  1. 执行本地操作，例如索引或删除相关文档，这同样验证字段内容并在必要时拒绝（例如：一个对于Lucene索引中过长的关键字）
  1. 转发操作给每个 current in-sync copies set 中的复制分片。如果有多个复制，操作是并行的
  1. 一旦所有复制成功执行操作并返回响应到主分片，主分片通知请求客户端成功完成
* * 失败处理
 有许多在索引期间导致失败的可能——磁盘可能损毁，节点可能与集群中其他节点断开连接，或者一些错误的配置会导致尽管在主分片上成功，在复制分片上会失败。这些是罕见情况，但是主分片需要对他们进行响应。
 有一种情况时主分片自身失败，主分片节点主机会向主节点发送一条相关消息。这个索引操作将会等待主节点（默认最多一分钟）来选拔一个其他的复制分片作为新的主分片。然后这个操作会转发给新的主节点进行处理。注意主节点同样会监控nodes并且可能决定堆一个主分片进行降级。典型的在一个从集群中隔离出去的节点持有主分片时会发生。
 一旦操作在主分片上成功执行，主分片必须处理当在复制分片上执行时潜在的失败。这可能由分片上实际的失败或由于网络问题阻止操作到达复制分片（或阻止复制分片的响应）。所有的这些公用相同的结果：在in-sync replica set中的部分遗失了一个将被通知的操作。为了避免违反一致，主分片发送一个信息给主节点请求从in-sync replica set中移除可能有问题的分片。一旦主节点通知主分片这个分片已经移除了，主分片响应这个操作。注意master同样会通知其他节点开始构建一个新的复制分片来修复系统到健康状态。
 当转发一个操作到复制，主分片会使用复制分片确认其仍是一个有效的主分片。如果主分片由于网络分割（或者一个长GC）从集群中隔离，在他认识到他已经被降级前，他可能继续处理进入的索引操作。来自一个过时的主分片的操作会被复制分片拒绝。当主分片从复制分片收到由于不再是主分片的拒绝响应，主分片将会接触主节点并且会获知替代的主分片。然后这个操作会路由到主分片。
* * 当没有复制分片时会发生什么？
     当由于索引配置或仅仅单纯是因为所有的复制分片都失败了，导致这种情况，有一个有效的方案。在这种情况下主分片不适用任何外部校验处理操作，看起来可能会有问题。在另一方面，主分片无法自行失效其他分片而需要请求主节点进行这个行为。这意味着主节点知道主分片时唯一正确的复制。因此我们保证主节点不会提升任何其他（过时的）分片复制作为新的主分片并且任意进入主分片的索引操作不会遗失。自然，由于我们仅在单个数据复制点上运行，物理硬件问题会导致数据丢失。在`Wait For Active Shards`查看一些控制对策
* Basic read model 基本读取模式
 在Elasticsearch中读取可以通过ID进行非常轻量级的查找或使用复杂聚合花费大量CPU处理能力的重量级搜索请求。一个主备模型的优势是他保持所有分片的独立（with the exception of in-flight operations）。同样的，单个in-sync copy足以进行read请求服务。
 当一个节点接收到read请求，这个节点负责转发请求到相关分片，整理响应，并响应客户端。我们称这个节点为这个请求的协调节点。基本流程如下：
  1. 解析读请求到相关分片。注意由于多数搜索请求将发送到一个或多个索引，他们一般需要从多个分片读取，每一个表示不同的数据子集
  1. 从每个相关分片复制组选择分片的一个存活复制。可以为主分片，也可以为复制分片。默认的，Elasticsearch将会简单的轮流使用分片的复制
  1. 发送分片级别的read请求到选中的分片
  1. 结合响应结果并进行响应。注意在使用ID查找时只有一个相关分片，这个步骤将被跳过
* * 失败处理
 当一个分片的读请求响应失败，这个协调节点将会从相同的复制组选择一个其他的复制并发送这个分片级别的搜索请求来代替这个复制。在没有可用的分片复制时会导致重复失败。在一些情况下，如`_search`，Elasticsearch将偏向快速响应，即使只有部分结果，而不是等待问题被处理（部分结果在响应`_shards`头中指明）
* A few simple implications
 所有这些基本流程决定了Elasticsearch作为同时读写系统的行为。另外，由于读写请求可以并发执行，两个基础行为会相互影响。这有几个内在含义：
  1. Efficient reads
      一般操作下，每个读操作会在所有相关复制组上执行一次。仅在失败条件下同一分片的多个复制才会执行相同的搜索
  1. Read unacknowledged
      由于主分片先索引本地，然后复制请求，并发的读取可能在变更可见之前通知响应
  1. Two copies by default
      这个模型在仅维护两个数据复制时是容错的。这与基于指定数量的系统不同，它的最小容错数量为3
* Failures
 在失败时，有下面的可能
  1. A single shard can slow down indexing
      由于在每个操作期间主分片等待所有in-sync copies set中的索引，一个迟缓的分片会减慢整个复制组。这是我们为了前面提到的高效读取付出的代价。当然，缓慢的当个分片同样会减慢被路由到他的搜索
  1. Dirty reads
      一个隔离的主分片能够暴露写入并且不会进行通知。这是由于一个隔离的主分片仅在他向它的复制分片发送请求或是当无法访问主节点时才会认识到他被隔离了的事实导致的。这时操作已经被索引到这个主分片并且能被一个并发read读取。Elasticsearch通过每秒（默认）ping主节点并且在没有已知的主节点时拒绝索引操作来减少这种风险
* The Tip of the Iceberg
 这个文档提供Elasticsearch处理数据的一个高层概览。当然，还有很多事情要做。如primary terms,cluster state publishing 和 master election 都在使系统保持正确行为中发挥作用。这个文档同样没有掩盖已知的和重要的bugs（包括closed和open）。很难跟上GitHub。ELasticsearch在他们的网站上维护一个页面 https://www.elastic.co/guide/en/elasticsearch/resiliency/current/index.html 。强烈建议阅读它。